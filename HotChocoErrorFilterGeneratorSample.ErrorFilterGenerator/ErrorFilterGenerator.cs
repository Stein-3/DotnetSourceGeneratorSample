using System.Collections.Generic;
using System.Linq;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace HotChocoErrorFilterGeneratorSample.ErrorFilterGenerator
{
    [Generator]
    public class ErrorFilterGenerator : ISourceGenerator
    {
        public void Execute(GeneratorExecutionContext context)
        {
            if (!(context.SyntaxContextReceiver is MySyntaxReceiver syntexReceiver))
                return;

            var namespcaces = new List<string>();

            var errorBranchBuilder = new StringBuilder();
            foreach (var customExceptionProperty in syntexReceiver.CustomExceptionProperties)
            {
                errorBranchBuilder.Append($@"
            if (error.Exception is {customExceptionProperty.ExceptionClassName})
            {{
                return error
                    .WithCode(""{customExceptionProperty.Code}"")
                    .WithMessage(""{customExceptionProperty.Message}"");
            }}");

                if (!namespcaces.Contains(customExceptionProperty.NameSpace))
                {
                    namespcaces.Add(customExceptionProperty.NameSpace);
                }
            }

            var namespaceBuilder = new StringBuilder();
            foreach (var namespaceString in namespcaces)
            {
                namespaceBuilder.AppendLine($"using {namespaceString};");
            }

            var source = SourceText.From($@"// <auto-generated/>

{namespaceBuilder}

namespace HotChocoErrorFilterGeneratorSample.WebApi
{{
    public partial class ErrorFilter : IErrorFilter
    {{
        public IError OnError(IError error)
        {{
            {errorBranchBuilder}
            
            if (error.Exception is NullReferenceException)
            {{
                return error.WithCode(""xxx"");
            }}
            return error;
        }}
    }}
}}

", Encoding.UTF8);
            context.AddSource("ErrorFilter.g.cs", source);
        }

        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => new MySyntaxReceiver());
        }
    }
}

class MySyntaxReceiver : ISyntaxContextReceiver
{
    public IList<SampleAttributeProperty> CustomExceptionProperties { get; private set; } = new List<SampleAttributeProperty>();

    public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
    {
        if (context.Node is ClassDeclarationSyntax classDeclarationSyntax
            && classDeclarationSyntax.AttributeLists.Count > 0)
        {
            ITypeSymbol attributeClassSymbols = context.SemanticModel.GetDeclaredSymbol(classDeclarationSyntax) as ITypeSymbol;
            var exceptionAttribute = attributeClassSymbols.GetAttributes().FirstOrDefault(x => x.AttributeClass.Name == "ErrorAttribute");

            if (exceptionAttribute.ConstructorArguments.Count() == 2)
            {
                var attributeProperty = new SampleAttributeProperty()
                {
                    ExceptionClassName = attributeClassSymbols.Name,
                    NameSpace = attributeClassSymbols.ContainingNamespace.ToDisplayString(),
                    Code = int.Parse(exceptionAttribute.ConstructorArguments[0].Value.ToString()),
                    Message = exceptionAttribute.ConstructorArguments[1].Value.ToString()
                };
                CustomExceptionProperties.Add(attributeProperty);
            }

        }
    }
}

struct SampleAttributeProperty
{
    public string ExceptionClassName { get; set; }

    public string NameSpace { get; set; }

    public int Code { get; set; }

    public string Message { get; set; }
}
